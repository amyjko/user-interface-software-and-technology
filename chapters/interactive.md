As I've noted in past chapters, nothing about the user interface designs we use today is fundamental. When interacting with a computer meant _programming_ a computer, there were no notions of scroll bars, icons, or checkboxes. Instead, there were quirky experiments in interactive interfaces. Sutherland's Sketchpad envisioned pen-based interactions with constrained graphical objects. Englebart's NLS envisioned commands, data hierarchies, mice, and keyboards. Kay envisioned graphical objects playing in virtual windowed worlds. These were all very different visions for how people would engage computing interactively, and elements of each of these systems emerged as the core components of modern graphical user interfaces.

Most of these ideas came together at Xerox PARC during the design and development of the Star. It's interface, shown above, contained all of the elements you're familiar with today. These elements are typically referred to with the acronym *WIMP*, which stands for Windows, Icons, Menus, and Pointer. This general paradigm, which leveraged a desktop metaphor full of files, programs, and interactive widgets such as buttons, scroll bars, toggles, and other controls, became the dominant paradigm for desktop computing. And the paradigm persists: even in the newest smartphone, tablet, and AR/VR operating systems, we still interact with windows, icons, menus and other widgets in nearly identical ways. We may use multi-touch or gesture interactions, but these are just other ways of pointing.

Because of their ubiquity, it's important to understand what problems WIMP was trying to solve, what big ideas emerged to solve these problems, and how researchers have built upon these big ideas to address their limitations. This chapter will focus deeply on these interactive interface basics before we dive more deeply into their implementation and explore alternatives to WIMP.

|https://www.youtube.com/embed/9qtd8Hc90Hw|All the widgets|User interface widgets are invented.|Brad Myers|

# Windows, icons, menus, and pointers

The first big idea is *windows*. The fundamental problem that windows solve is _how to provide visual access to a potentially infinite amount of content larger than the size of a screen on a fixed size display_. Closely related to windows are scroll bars, which solve the problem of how to _navigate_ this content. In the "All the Widgets" video above, you can see a wide range of alternatives for how windows and scroll bars could work. Some were just directional, instructing the window to move up or down a content area, much like the swiping gestures we use on touchscreens today to scroll. Others used a scroll bar "knob" to control what part of a larger document the window would show, where the size of the knob was proportional to the amount of content visible in the window (this is the idea that we see in operating systems today). Researchers have since explored many more advanced techniques for windows and scrolling, including forms of scrolling that are aware of the underlying content to support non-linear navigation paths<ishak06>, hardware input devices such as "scroll rings" to support movement through documents<moscovich04>, and techniques for intelligently collapsing content in displays to help a user focus on the content most relevant to their task<baudisch04>. _Responsive web design_ shares similar ideas to these content aware techniques, in that it aims to automatically lay out content on a screen to fit the physical dimensions of different screen sizes<marcotte10>. All of these techniques involve linking metadata about the content to the layout and navigation of that content.
		
|tiled.png|A diagram of a window tiling arrangement.|Windows didn't always work the way they do now.|Brad Myers<myers88>|

Closely related to windows are *window managers*. If you're going to have windows that arrange content, how should the windows themselves be arranged? There have been countless ideas for this. The Star had windows that could be resized, dragged, and overlapped, just like the original Macintosh. Early versions of Windows had _tiled_ windows (as shown above), which were non-overlapping grids of windows. Windows, macOS, and Ubuntu have many advanced window management features, allowing the user to see a zoomed out view with all active windows and move them to different virtual desktops. Modern mobile operating systems such as iOS, Android, and Windows Phone all eschewed multiple windows for a paradigm of one full-screen window at a time with navigation features for moving between full-screen applications. Researchers in the 1980's were behind many of these innovations<myers88>, and researchers continue to innovate.  For example, some have explored windows that are organized by tasks<tashman06>.

 Another big idea from WIMP was *icons*. Icons solve the problem of providing visual access to programs and documents on a computer. Before icons, the way to access programs and documents was through command line operations: navigating from one directory to another, moving files from one directory to another, and launching programs by passing filenames as arguments. With icons, all of these operations could be mapped to a pointing device instead of a keyboard: double-clicking on a program to launch it, double-clicking on a document to open it, and using menus to perform operations on a program or document. This also necessitated some notion of a "desktop," on which program and document icons would be stored, providing a convenient place to start work. Again, none of these ideas _had_ to work this way, and in fact, newer operating systems don't: iOS does not expose a concept of files, documents, or icons that represent them, nor does it have a desktop. Instead, there are only icons for programs, and data is presented as living only "inside" that application. Of course, there are still files stored on the device, they are just managed by the application instead of by the user.

|fisheye-menus.png|A screenshot of fisheye menus, showing menu items with different label sizes, some too small to read, and others magnified|Fisheye menus|Bederson<bederson00>|

Programs have commands, which are essentially an API of functions that can be called to perform useful operations. But how can those commands be executed without requiring a user to learn a command line syntax for invoking those commands? *Menus* solve this problem by providing visual lists of available commands. The earliest menus were simple lists of commands that could be selected with a pointing device. Some menus were attached to the border of a window, others were anchored to the top of the screen, and others still were _contextual_ and attached to a specific icon or object representing some data, document, or program. You see all of these different types of menus in modern interfaces, with wide variation in where a menu is invoked.  Researchers have long studied more effective menus than linear lists of labels, including things like _hierarchical marking menus_ that are radial, can be moved through without clicking, and can result in a memory for pointing trajectories for rapid selection of items<zhao04>. Other ideas have included menus that follow the mouse for quick access to contextual functionality<fitzmaurice03> and fisheye menus that scale the size of command descriptions to fit larger numbers of commands in the same amount of space.

Menus to invoke commands are great, but what about commands that require other input to execute? For example, imagine a menu item labeled "Sign in..." that signs the user into a service? How can users provide that input?  That's why *dialogs* and *forms* were invented.  They solve the problem of gathering user input that will be given to a command to invoke. All forms and dialogs are essentially ways of soliciting input from users for command invocation, whether they are single popup dialogs or "wizards" that have multiple screens of forms to fill out. In response to the highly constrained nature of most dialogs, some researchers have explored dialogs that gather input from users in a floating dialog that still allows the user to interact with an application, so they can get information necessary to provide input<quan03>.

 What about sliders, check boxes, text boxes, radio buttons, drop down menus, and all of the other *widgets* that make up graphical user interfaces? These solve the problem of enabling users to provide specific types of user input efficiently and without errors. 

* *Sliders* provide a control for specifying continuous numeric values within a numeric range.
* *Checkboxes* provide an error-free mechanism for specifying binary values (and sometimes tertiary values, which are often represented by a dash).
* *Text boxes* provide an interface for specifying string values, often with sophisticated error-prevention mechanisms such as form validation and user efficiency features such as auto-complete
* *Radio buttons* and *drop down menus* provide error-preventing interfaces for specifying categorical values.

Each one of these widgets, as portrayed in the "All the widgets" video earlier, has been carefully designed to allow rapid, error-free, efficient input of each of these data types. Of course, since these early widgets were invented, researchers have discovered many other types of widgets designed for data types that don't map well onto this small set of primitive widgets. For example, some researchers have designed widgets for selecting time values on non-linear scales<koike97>.

 Another big idea in WIMP interfaces is the idea of *copy and paste*. This idea solves the basic problem of moving data from one place to another when that data is not stored in a file, or not stored in a file accessible to the user. As you probably know, copy and paste is actually one of the most critical features of user interfaces, allowing users to move information regardless of where it comes from. Researchers have explored many ways to improve the power of this feature, including techniques that have greater semantic awareness of the content being copied, allowing it to be parsed and pasted in more intelligent ways<stylos04>. Others have explored ways of moving data between different machines by giving copied data identity<rekimoto97> or by synchronizing clipboards across devices<miller99>. Some of these features are now mainstream; for example, iOS supports a cloud-based synchronized keyboard that enables pasting content between different devices logged into the same iCloud account.

Finally, WIMP interfaces involve some form of pointing, a necessary part of selecting menus, icons, and windows. A later chapter will [discuss pointing in detail|pointing].

# Direct manipulation

Another central paradigm of WIMP interfaces is *direct manipulation*<hutchins85>. (Although note that direct manipulation applies to more than just WIMP interfaces). The essential idea behind direct manipulation is that:
		
* The object of interest is always represented visually.
* Operating on the object involves invoking commands through physical action rather than programming.
* Feedback on the effect of an operation is immediately visible and is reversible.

Direct manipulation interfaces, which include things like drag and drop interactions and operations in drawing and painting programs, can be learned quickly, can be efficient to use, can prevent errors, and, because they are reversible, can support rapid error recovery.  Because of these benefits, many researchers have tried to translate tasks that traditionally require programming or other complex sequences of operations into direct manipulation interfaces. Early work explored things like alignment guides in drawing programs<raisamo96>, now popular in most graphic design software. Others have explored extensions of drag and drop to multiple devices, or more complex data manipulations<kobayashi07>. More recently, researchers have applied techniques from programming languages and machine learning to support automatically converting sketches into scalable vector graphics suitable for the web<hempel17>, to define the layout of data visualizations<hottelier14>, and to manipulate speech music and other audio more directly<rubin13>. All of these leverage the same basic paradigm of explicit representation and manipulation of an object.

# WIMP isn't natural, its invented

While all of the interactive interface ideas above are probably deeply familiar to you, it is important to remember that they are not natural in any way. They are entirely invented, artificial designs that solve very specific problems of presenting information to users, getting data from users, and supporting command invocation. The only reason they _feel_ natural is because we practice using them so frequently. In designing interfaces, it's reasonable to leverage everyone's long history of practice with these old ideas. However, it's also reasonable to question  them when dealing with new types of data or interaction.

