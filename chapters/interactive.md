As I've noted in past chapters, nothing about the user interface designs we use today is fundamental. When interacting with a computer meant _programming_ a computer, there were no notions of scroll bars, icons, or check boxes. Instead, there were quirky experiments in interactive interfaces. Sutherland's Sketchpad envisioned pen-based interactions with constrained graphical objects. Englebart's NLS envisioned commands, data hierarchies, mice, and keyboards. Kay envisioned graphical objects playing in virtual windowed worlds. These were all very different visions for how people would engage computing interactively, and elements of each of these systems emerged as the core components of modern graphical user interfaces.

Most of these ideas came together at Xerox PARC during the design and development of the Star. Its interface, shown above, contained all of the elements you're familiar with today. These elements are typically referred to with the acronym *WIMP*, which stands for Windows, Icons, Menus, and Pointer. This general paradigm, which leveraged a desktop metaphor full of files, programs, and interactive widgets such as buttons, scroll bars, toggles, and other controls, became the dominant paradigm for desktop computing. And the paradigm persists: even in the newest smartphone, tablet, and AR/VR operating systems, we still interact with windows, icons, menus and other widgets in nearly identical ways. We may use multi-touch or gesture interactions, but these are just other ways of pointing.

Because of their ubiquity, it's important to understand what problems WIMP was trying to solve, what big ideas emerged to solve these problems, and how researchers have built upon these big ideas to address their limitations. This chapter will focus deeply on these interactive interface basics before we dive more deeply into their implementation and explore alternatives to WIMP.

# Windows, icons, menus, and pointers

WIMP interfaces have four key elements, but have grown to include much more. We'll discuss each of these elements, then the things that have been added on since.

## Windows: an infinite screen
The first big idea is *windows*. The fundamental problem that windows solve is _how to provide visual access to a potentially infinite amount of content larger than the size of a screen on a fixed size display_. Closely related to windows are scroll bars, which solve the problem of how to _navigate_ this content. In this "All the Widgets" video, you can see a wide range of alternatives for how windows and scroll bars could work:

|https://www.youtube.com/embed/9qtd8Hc90Hw|All the widgets|User interface widgets are invented.|Brad Myers|

Some were just directional, instructing the window to move up or down a content area, much like the swiping gestures we use on touchscreens today to scroll. Others used a scroll bar "knob" to control what part of a larger document the window would show, where the size of the knob was proportional to the amount of content visible in the window (this is the idea that we see in operating systems today). Researchers have since explored many more advanced techniques for windows and scrolling, including forms of scrolling that are aware of the underlying content to support non-linear navigation paths<ishak06>, hardware input devices such as "scroll rings" to support movement through documents<moscovich04>, and techniques for intelligently collapsing content in displays to help a user focus on the content most relevant to their task<baudisch04>. _Responsive web design_ shares similar ideas to these content aware techniques, in that it aims to automatically lay out content on a screen to fit the physical dimensions of different screen sizes<marcotte10>. All of these techniques involve linking metadata about the content to the layout and navigation of that content.
		
|tiled.png|A diagram of a window tiling arrangement.|Windows didn't always work the way they do now.|Brad Myers<myers88>|

Closely related to windows are *window managers*. If you're going to have windows that arrange content, how should the windows themselves be arranged? There have been countless ideas for this. The Star had windows that could be resized, dragged, and overlapped, just like the original Macintosh. Early versions of Windows had _tiled_ windows (as shown above), which were non-overlapping grids of windows. Windows, macOS, and Ubuntu have many advanced window management features, allowing the user to see a zoomed out view with all active windows and move them to different virtual desktops. Modern mobile operating systems such as iOS, Android, and Windows Phone all eschewed multiple windows for a paradigm of one full-screen window at a time with navigation features for moving between full-screen applications. Researchers in the 1980's were behind many of these innovations<myers88>, and researchers continue to innovate.  For example, some have explored windows that are organized by tasks<tashman06>.

## Icons: visualizing files, folders, and programs

 Another big idea from WIMP was *icons*. Icons solve the problem of providing visual access to programs and documents on a computer. Before icons, the way to access programs and documents was through command line operations: navigating from one directory to another, moving files from one directory to another, and launching programs by passing filenames as arguments. With icons, all of these operations could be mapped to a pointing device instead of a keyboard: double-clicking on a program to launch it, double-clicking on a document to open it, and using menus to perform operations on a program or document. This also necessitated some notion of a "desktop," on which program and document icons would be stored, providing a convenient place to start work. Again, none of these ideas _had_ to work this way, and in fact, newer operating systems don't: iOS does not expose a concept of files, documents, or icons that represent them, nor does it have a desktop. Instead, there are only icons for programs, and data is presented as living only "inside" that application. Of course, there are still files stored on the device, they are just managed by the application instead of by the user.

|fisheye-menus.png|A screenshot of fisheye menus, showing menu items with different label sizes, some too small to read, and others magnified|Fisheye menus|Bederson<bederson00>|

## Menus: visualizing actions

Programs have commands, which are essentially an API of functions that can be called to perform useful operations. But how can those commands be executed without requiring a user to learn a command line syntax for invoking those commands? *Menus* solve this problem by providing visual lists of available commands. The earliest menus were simple lists of commands that could be selected with a pointing device. Some menus were attached to the border of a window, others were anchored to the top of the screen, and others still were _contextual_ and attached to a specific icon or object representing some data, document, or program. You see all of these different types of menus in modern interfaces, with wide variation in where a menu is invoked.  Researchers have long studied more effective menus than linear lists of labels, including things like _hierarchical marking menus_ that are radial, can be moved through without clicking, and can result in a memory for pointing trajectories for rapid selection of items<zhao04>. Other ideas have included menus that follow the mouse for quick access to contextual functionality<fitzmaurice03> and fisheye menus that scale the size of command descriptions to fit larger numbers of commands in the same amount of space.

Menus to invoke commands are great, but what about commands that require other input to execute? For example, imagine a menu item labeled "Sign in..." that signs the user into a service. How can users provide that input?  That's why *dialogs* and *forms* were invented.  They solve the problem of gathering user input that will be given to a command to invoke. All forms and dialogs are essentially ways of soliciting input from users for command invocation, whether they are single popup dialogs or "wizards" that have multiple screens of forms to fill out. In response to the highly constrained nature of most dialogs, some researchers have explored dialogs that gather input from users in a floating dialog that still allows the user to interact with an application, so they can get information necessary to provide input<quan03>.

## Pointers: indicating selections

None of the core WIMP actions above are possible without the last element, *pointers*, which enable a user to indicate the window they want to move or resize, the icon they want to select, or the menu item they want to invoke. The key insight behind pointing is that so much about interacting with a computer requires a precise statement of _what_ is being "discussed" in the dialog between the user and the computer. Pointers are a way of indicating the topic of discussion, just as pointing is in conversations between people. 

The power of this idea becomes apparent when we consider interfaces without pointers. Consider, for example, speech interfaces. How might you tell a computer that you want to delete a file? In a speech interface, we might have to say something like "Delete the file in the folder named 'Documents' that has the name 'report.txt'", and it would be up to the computer to search for such a file, ask for clarification if there was more than one match, return an error if nothing was found, and of course, deal with any speech recognition mistakes that it made. Pointers solve all of those problems with a single elegant interaction, borrowed from human interaction. We will talk about [pointing|pointing] in more detail in a later chapter.

## Widgets: expanding the palette

One _can_ build entire interfaces out of windows, icons, menus, and pointers. However, application designers quickly realized that users need to do more than just open files, folders, and programs: they also need to provide input. *Widgets* are how we do this: sliders, check boxes, text boxes, radio buttons, drop down menus, and the many other controls found in graphical user interfaces are generally designed to make it possible to precisely specify an input within a certain set of constraints:

* *Sliders* provide a control for specifying continuous numeric values within a numeric range.
* *Check boxes* provide an error-free mechanism for specifying binary values (and sometimes tertiary values, which are often represented by a dash).
* *Text boxes* provide an interface for specifying string values, often with sophisticated error-prevention mechanisms such as form validation and user efficiency features such as auto-complete.
* *Radio buttons* and *drop down menus* provide error-preventing interfaces for specifying categorical values.

Each one of these widgets has been carefully designed to allow rapid, error-free, efficient input of each of these data types, and none were immediately obvious.

Of course, since these early widgets were invented, researchers have discovered many other types of widgets designed for data types that don't map well onto this small set of primitive widgets. For example, some researchers have designed widgets for selecting time values on non-linear scales<koike97>.

## Copy and paste: transferring data

Another gap that the early inventors of WIMP interfaces noticed is that there was no easy way to move information between parts of interfaces. Prior to WIMP interfaces, copying information meant storing some information in a file, copying the file or concatenating its contents to another file, and then saving that file. *Copy and paste* brilliantly streamlined this data transfer process by simply creating a temporary storage place for data is not stored in a file. Researchers have explored many ways to improve the power of this feature, including techniques that have greater semantic awareness of the content being copied, allowing it to be parsed and pasted in more intelligent ways<stylos04>. Others have explored ways of moving data between different machines by giving copied data identity<rekimoto97> or by synchronizing clipboards across devices<miller99>. Some of these features are now mainstream; for example, iOS supports a cloud-based synchronized keyboard that enables pasting content between different devices logged into the same iCloud account.

# Direct manipulation

Throughout WIMP interfaces, there is a central notion of _immediacy_: one takes an action and gets a response. This idea, which we call *direct manipulation*<hutchins85>, is not specific to WIMP, but far more general. The essence behind direct manipulation is:

* The object of interest is always represented visually (e.g., the file you want to move is presented on a screen).
* Operating on the object involves invoking commands through physical action rather than programming (e.g., click and drag the file from the current folder to a different folder instead of writing a command line command telling the computer to move it).
* Feedback on the effect of an operation is immediately visible and is reversible (e.g., as you drag, the file moves, and if you change your mind, you can just move it back).

Direct manipulation interfaces, which include things like drag and drop interactions and operations in drawing and painting programs, can be learned quickly, can be efficient to use, can prevent errors, and, because they are reversible, can support rapid error recovery.  Because of these benefits, many researchers have tried to translate tasks that traditionally require programming or other complex sequences of operations into direct manipulation interfaces. Early work explored things like alignment guides in drawing programs<raisamo96>, now popular in most graphic design software. Others have explored extensions of drag and drop to multiple devices, or more complex data manipulations<kobayashi07>. More recently, researchers have applied techniques from programming languages and machine learning to support automatically converting sketches into scalable vector graphics suitable for the web<hempel17>, to define the layout of data visualizations<hottelier14>, and to manipulate speech, music, and other audio more directly<rubin13>. All of these leverage the same basic paradigm of explicit representation and manipulation of an object.

|zelda.png|A screenshot of the original Legend of Zelda, showing link swinging his sword at an octorok|A non-WIMP interface|Fair use|

# Non-WIMP interfaces

While all of the interactive interface ideas above are probably deeply familiar to you, it is important to remember that they are not natural in any way. They are entirely invented, artificial designs that solve very specific problems of presenting information to users, getting data from users, and supporting command invocation. The only reason they _feel_ natural is because we practice using them so frequently. In designing interfaces, it's reasonable to leverage everyone's long history of practice with these old ideas. However, it's also reasonable to question them when dealing with new types of data or interaction.

Games are the perfect example of this. They may have WIMP ideas in home screens and settings like menus and buttons, but the game play itself, and even some aspects of game menus, may avoid many aspects of WIMP. Consider for example, the lack of pointers on many video game consoles: rather than pointing to something, navigation is often by a directional pad or analog stick, giving discrete or continuous input about which trajectory a player wants to navigate in some space, but not a particular target. Or, consider the presence of non-player characters in games: the goal is not to execute commands on those characters, but interact with them for information, fight them, or perhaps even avoid them, and these behaviors are often not triggered by selecting things and invoking commands, but by pressing buttons, coming near something, or other gestures. These interfaces are still graphical, and often still have all of the features of direct manipulation, but are not WIMP in their interface metaphor.

# Graphical user interfaces aren't natural

As should be clear from the history above, nothing about graphical user interfaces is natural: every single aspect of them was invented to solve a particular problem, and could have been invented differently. One might argue, however, that humans do have relatively fixed abilities, and so some aspects of interactive interfaces were inevitable (we point to things in the physical world, so why wouldn't we point to things in the virtual world?). Even if this is the case, it still takes hard work to invent these ways. Only after we find great designs do they become so ubiquitious that we take them for granted.

